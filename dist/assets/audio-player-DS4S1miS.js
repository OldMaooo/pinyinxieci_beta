class f{constructor(){this.ctx=null,this.gain=null,this.bufferCache=new Map,this.currentSource=null,this.isInitialized=!1,this.useWebAudio=!1}async init(){if(this.isInitialized)return;const t=window.AudioContext||window.webkitAudioContext;if(t)try{this.ctx=new t,this.gain=this.ctx.createGain(),this.gain.connect(this.ctx.destination),this.useWebAudio=!0}catch{this.ctx=null}this.isInitialized=!0}async resumeContextIfNeeded(){this.ctx&&this.ctx.state==="suspended"&&await this.ctx.resume()}async loadBuffer(t){if(this.bufferCache.has(t))return this.bufferCache.get(t);try{const r=await(await fetch(t)).arrayBuffer(),n=await this.ctx.decodeAudioData(r);return this.bufferCache.set(t,n),n}catch(e){throw this.bufferCache.delete(t),e}}async play(t,{volume:e=.2,loop:r=!1,type:n="buffer"}={}){if(!t)return;if(await this.init(),await this.resumeContextIfNeeded(),this.stop(),this.useWebAudio&&this.ctx&&this.ctx.state!=="closed")try{let s=this.bufferCache.get(t);if(!s){const h=await(await fetch(t)).arrayBuffer();s=await this.ctx.decodeAudioData(h),this.bufferCache.set(t,s)}const i=this.ctx.createBufferSource();i.buffer=s;const u=this.ctx.createGain();u.gain.value=typeof e=="number"?e:.2,i.connect(u),u.connect(this.ctx.destination),i.loop=r,i.start(0),this.currentSource=i,i.onended=()=>{this.currentSource===i&&(this.currentSource=null)};return}catch{this.useWebAudio=!1}const c=new Audio(t);c.volume=typeof e=="number"?e:.2,c.loop=!!r,c.play().catch(()=>{}),this.currentSource=c}stop(){if(this.currentSource){if(this.useWebAudio&&this.currentSource.stop)try{this.currentSource.stop()}catch{}else this.currentSource instanceof HTMLAudioElement&&(this.currentSource.pause(),this.currentSource.currentTime=0);this.currentSource=null}}setVolume(t){this.gain&&this.ctx?this.gain.gain.value=t:this.currentSource&&this.currentSource instanceof HTMLAudioElement&&(this.currentSource.volume=t)}}const o=new f;if(typeof window<"u")try{window.playCardAudio=(a,t)=>o.play(a,t||{}),window.__audioPlayer__=o}catch{}export{o as default};
