<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³æµ‹è¯• Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f0f9ff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
        }
        h1 {
            color: #0369a1;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #64748b;
            margin-bottom: 40px;
        }
        .container {
            max-width: 600px;
            width: 100%;
        }
        .unlock-section {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        .unlock-section h2 {
            color: #92400e;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .unlock-section p {
            color: #b45309;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        .unlock-btn {
            background: #f59e0b;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .unlock-btn:hover {
            background: #d97706;
            transform: translateY(-2px);
        }
        .unlock-btn:active {
            transform: translateY(0);
        }
        .unlock-btn.unlocked {
            background: #10b981;
            cursor: default;
        }
        .characters {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .char-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
        }
        .char-card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }
        .char-card.speaking {
            border: 2px solid #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        .char-display {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .chinese-char {
            font-size: 3em;
            font-family: 'STKaiti', 'KaiTi', 'æ¥·ä½“', serif;
            color: #1e40af;
            min-width: 80px;
            text-align: center;
        }
        .char-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .char-pinyin {
            font-size: 1.1em;
            color: #64748b;
        }
        .char-english {
            font-size: 0.9em;
            color: #94a3b8;
        }
        .play-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        .play-btn:active {
            transform: scale(0.95);
        }
        .play-btn.playing {
            background: linear-gradient(135deg, #64748b, #475569);
            cursor: default;
        }
        .status-bar {
            margin-top: 10px;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .status-bar.visible {
            opacity: 1;
        }
        .status-progress {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.1s linear;
            width: 0%;
        }
        .debug-console {
            margin-top: 30px;
            background: #1e293b;
            border-radius: 12px;
            padding: 20px;
            color: #94a3b8;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85em;
            max-height: 300px;
            overflow-y: auto;
        }
        .debug-console h3 {
            color: #e2e8f0;
            margin-bottom: 10px;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .debug-console h3::before {
            content: 'ğŸ”§';
        }
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #334155;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        .log-time {
            color: #64748b;
            margin-right: 8px;
        }
        .log-info { color: #60a5fa; }
        .log-success { color: #4ade80; }
        .log-error { color: #f87171; }
        .log-warning { color: #fbbf24; }
        .browser-info {
            background: #dbeafe;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .browser-info h3 {
            color: #1e40af;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .browser-info p {
            color: #3b82f6;
            font-size: 0.85em;
            margin: 4px 0;
        }
    </style>
</head>
<body>
    <h1>ğŸ™ï¸ è¯­éŸ³åˆæˆæµ‹è¯•</h1>
    <p class="subtitle">æç®€ç‰ˆ - åªæµ‹è¯•æµè§ˆå™¨åŸç”Ÿ TTS</p>

    <div class="container">
        <div class="browser-info">
            <h3>æµè§ˆå™¨ç¯å¢ƒä¿¡æ¯</h3>
            <p id="browserUA">æ£€æµ‹ä¸­...</p>
            <p id="speechSupport">æ£€æµ‹ä¸­...</p>
            <p id="speechState">è¯­éŸ³å¼•æ“çŠ¶æ€: æ£€æµ‹ä¸­...</p>
        </div>

        <div class="unlock-section">
            <h2>âš ï¸ é¦–å…ˆéœ€è¦è§£é”éŸ³é¢‘</h2>
            <p>æµè§ˆå™¨é™åˆ¶ï¼šå¿…é¡»å…ˆç‚¹å‡»æŒ‰é’®æ‰èƒ½æ’­æ”¾å£°éŸ³</p>
            <button class="unlock-btn" id="unlockBtn" onclick="unlockAudio()">
                ğŸ”“ è§£é”éŸ³é¢‘
            </button>
            <button class="unlock-btn" id="resetBtn" onclick="resetSpeechEngine()" style="margin-left: 10px; background: #64748b;">
                ğŸ”„ å¼ºåˆ¶é‡ç½®
            </button>
            <button class="unlock-btn" id="testSystemAudio" onclick="testSystemAudio()" style="margin-left: 10px; background: #8b5cf6;">
                ğŸ”Š æµ‹è¯•ç³»ç»ŸéŸ³
            </button>
        </div>

        <div class="characters" id="characterList">
        </div>

        <div class="debug-console">
            <h3>è°ƒè¯•æ—¥å¿—</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        // Test data - 3 simple Chinese characters
        const testCharacters = [
            { char: 'ä½ ', pinyin: 'nÇ', english: 'you' },
            { char: 'å¥½', pinyin: 'hÇo', english: 'good' },
            { char: 'å—', pinyin: 'ma', english: 'question particle' }
        ];

        let isAudioUnlocked = false;
        let currentSpeaking = null;
        let speechSynth = window.speechSynthesis;
        let voices = [];

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('info', 'é¡µé¢åŠ è½½å®Œæˆ');

            // Check browser support
            const ua = navigator.userAgent;
            document.getElementById('browserUA').textContent = `User Agent: ${ua}`;

            if ('speechSynthesis' in window) {
                document.getElementById('speechSupport').textContent = 'âœ… æ”¯æŒ Web Speech API (speechSynthesis)';
                log('success', 'æµè§ˆå™¨æ”¯æŒ speechSynthesis');

                // Load voices
                loadVoices();
                speechSynth.onvoiceschanged = loadVoices;
            } else {
                document.getElementById('speechSupport').textContent = 'âŒ ä¸æ”¯æŒ Web Speech API';
                log('error', 'æµè§ˆå™¨ä¸æ”¯æŒ speechSynthesis');
            }

            // Render character cards
            renderCharacters();

            // Start monitoring speech state
            setInterval(updateSpeechState, 1000);

            log('info', 'åˆå§‹åŒ–å®Œæˆï¼Œç­‰å¾…è§£é”éŸ³é¢‘');
        });

        function updateSpeechState() {
            if (!speechSynth) return;

            const speaking = speechSynth.speaking;
            const pending = speechSynth.pending;
            const paused = speechSynth.paused;

            const statusText = `è¯­éŸ³å¼•æ“çŠ¶æ€: ${speaking ? 'ğŸ”Š æ’­æ”¾ä¸­' : 'â¸ï¸ ç©ºé—²'} | é˜Ÿåˆ—: ${pending ? 'â³ æœ‰ç­‰å¾…' : 'âœ… æ— '} | æš‚åœ: ${paused ? 'â¯ï¸ æ˜¯' : 'âŒ å¦'}`;
            document.getElementById('speechState').textContent = statusText;
        }

        function loadVoices() {
            voices = speechSynth.getVoices();
            const chineseVoices = voices.filter(v => v.lang.includes('zh') || v.lang.includes('CN'));
            log('info', `æ£€æµ‹åˆ° ${voices.length} ä¸ªè¯­éŸ³ï¼Œå…¶ä¸­ ${chineseVoices.length} ä¸ªä¸­æ–‡è¯­éŸ³`);

            if (chineseVoices.length > 0) {
                log('success', 'ä¸­æ–‡è¯­éŸ³ç¤ºä¾‹: ' + chineseVoices.slice(0, 2).map(v => v.name).join(', '));
            }
        }

        function renderCharacters() {
            const container = document.getElementById('characterList');

            testCharacters.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'char-card';
                card.id = `card-${index}`;

                card.innerHTML = `
                    <div class="char-display">
                        <div class="chinese-char">${item.char}</div>
                        <div class="char-info">
                            <div class="char-pinyin">${item.pinyin}</div>
                            <div class="char-english">${item.english}</div>
                        </div>
                    </div>
                    <div>
                        <button class="play-btn" id="play-${index}" onclick="speak(${index})">
                            â–¶ï¸
                        </button>
                        <div class="status-bar" id="status-${index}">
                            <div class="status-progress" id="progress-${index}"></div>
                        </div>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function unlockAudio() {
            log('info', 'å°è¯•è§£é”éŸ³é¢‘...');
            const btn = document.getElementById('unlockBtn');
            btn.disabled = true;
            btn.textContent = 'â³ è§£é”ä¸­...';

            try {
                // Cancel any ongoing speech
                speechSynth.cancel();
                log('info', 'Step 1: å–æ¶ˆå½“å‰è¯­éŸ³');

                // Strategy 1: Multiple attempts with short delays
                let attempts = 0;
                const maxAttempts = 5;
                const testPhrase = 'ä½ å¥½';

                const tryUnlock = () => {
                    attempts++;
                    log('info', `Step 2: å°è¯• ${attempts}/${maxAttempts} - æ’­æ”¾æµ‹è¯•è¯­éŸ³ "${testPhrase}"`);

                    const utterance = new SpeechSynthesisUtterance(testPhrase);
                    utterance.rate = 1.0;
                    utterance.volume = 0.1; // Low volume for testing

                    // Find Chinese voice
                    const zhVoice = voices.find(v => v.lang.includes('zh') || v.lang.includes('CN'));
                    if (zhVoice) {
                        utterance.voice = zhVoice;
                        utterance.lang = zhVoice.lang;
                    }

                    utterance.onstart = () => {
                        log('success', `âœ… å°è¯• ${attempts} æˆåŠŸï¼è¯­éŸ³å¼•æ“å·²æ¿€æ´»`);
                        isAudioUnlocked = true;
                        btn.textContent = 'âœ… å·²è§£é”';
                        btn.classList.add('unlocked');
                    };

                    utterance.onend = () => {
                        if (isAudioUnlocked) {
                            log('success', 'éŸ³é¢‘å®Œå…¨è§£é”');
                        } else if (attempts < maxAttempts) {
                            log('warning', `å°è¯• ${attempts} å¤±è´¥ï¼Œé‡è¯•ä¸­...`);
                            setTimeout(tryUnlock, 300);
                        } else {
                            log('error', `æ‰€æœ‰ ${maxAttempts} æ¬¡å°è¯•éƒ½å¤±è´¥äº†`);
                            btn.disabled = false;
                            btn.textContent = 'ğŸ”„ é‡è¯•è§£é”';
                        }
                    };

                    utterance.onerror = (event) => {
                        if (!isAudioUnlocked && attempts < maxAttempts) {
                            log('warning', `å°è¯• ${attempts} é”™è¯¯: ${event.error}, é‡è¯•ä¸­...`);
                            setTimeout(tryUnlock, 300);
                        } else if (!isAudioUnlocked) {
                            log('error', `æ‰€æœ‰ ${maxAttempts} æ¬¡å°è¯•éƒ½å¤±è´¥äº†ï¼Œé”™è¯¯: ${event.error}`);
                            btn.disabled = false;
                            btn.textContent = 'ğŸ”„ é‡è¯•è§£é”';
                        }
                    };

                    const result = speechSynth.speak(utterance);
                    log('info', `speechSynthesis.speak() è¿”å›: ${result}`);

                    if (result === false) {
                        log('error', 'speechSynthesis.speak() è¿”å› false');
                    }
                };

                // Wait a bit for voices to load
                setTimeout(() => {
                    log('info', 'Step 2: å¼€å§‹è§£é”å°è¯•');
                    tryUnlock();
                }, 200);

            } catch (error) {
                log('error', 'è§£é”å¤±è´¥: ' + error.message);
                btn.disabled = false;
                btn.textContent = 'ğŸ”„ é‡è¯•è§£é”';
            }
        }

        function speak(index) {
            if (!isAudioUnlocked) {
                log('warning', 'è¯·å…ˆç‚¹å‡»"è§£é”éŸ³é¢‘"æŒ‰é’®');
                alert('è¯·å…ˆç‚¹å‡»"è§£é”éŸ³é¢‘"æŒ‰é’®');
                return;
            }

            // Stop any current speech
            if (currentSpeaking !== null) {
                stopSpeaking();
            }

            const item = testCharacters[index];
            const card = document.getElementById(`card-${index}`);
            const btn = document.getElementById(`play-${index}`);
            const statusBar = document.getElementById(`status-${index}`);
            const progressBar = document.getElementById(`progress-${index}`);

            log('info', `å‡†å¤‡æœ—è¯»: "${item.char}" (${item.pinyin})`);

            // Find Chinese voice
            const zhVoice = voices.find(v => v.lang.includes('zh') || v.lang.includes('CN'));

            // Create utterance
            const utterance = new SpeechSynthesisUtterance(item.char);

            if (zhVoice) {
                utterance.voice = zhVoice;
                utterance.lang = zhVoice.lang;
                log('info', `ä½¿ç”¨è¯­éŸ³: ${zhVoice.name} (lang: ${zhVoice.lang})`);
            } else {
                log('warning', 'æœªæ‰¾åˆ°ä¸­æ–‡è¯­éŸ³ï¼Œä½¿ç”¨é»˜è®¤è¯­éŸ³');
            }

            utterance.rate = 0.9;
            utterance.pitch = 1;
            utterance.volume = 1.0;

            // Additional diagnostics
            log('info', `è¯­éŸ³å‚æ•°: rate=${utterance.rate}, pitch=${utterance.pitch}, volume=${utterance.volume}`);
            log('info', `å½“å‰è¯­éŸ³é˜Ÿåˆ—é•¿åº¦: ${speechSynth.pending ? 'æœ‰' : 'æ— '}`);

            // Update UI on start
            utterance.onstart = () => {
                currentSpeaking = index;
                card.classList.add('speaking');
                btn.textContent = 'ğŸ”Š';
                btn.classList.add('playing');
                statusBar.classList.add('visible');
                log('success', `âœ… å¼€å§‹æœ—è¯»: "${item.char}"`);
            };

            // Update progress
            utterance.onboundary = (event) => {
                if (event.name === 'word') {
                    log('info', `è¯­éŸ³è¾¹ç•Œ: ${event.charIndex}`);
                }
            };

            // Reset UI on end
            utterance.onend = () => {
                log('success', `âœ… æœ—è¯»å®Œæˆ: "${item.char}"`);
                resetCard(index);
            };

            // Handle errors
            utterance.onerror = (event) => {
                log('error', `âŒ æœ—è¯»é”™è¯¯: ${event.error}`);
                log('error', `é”™è¯¯è¯¦æƒ…: ${event.error}, ${event.message}`);
                resetCard(index);
            };

            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                if (currentSpeaking !== index) {
                    clearInterval(progressInterval);
                    return;
                }
                progress += 2;
                if (progress > 100) progress = 100;
                progressBar.style.width = progress + '%';
            }, 50);

            // Speak with multiple fallback attempts
            let speakAttempts = 0;
            const maxSpeakAttempts = 3;

            const trySpeak = () => {
                speakAttempts++;
                log('info', `æ’­æ”¾å°è¯• ${speakAttempts}/${maxSpeakAttempts}`);

                try {
                    const result = speechSynth.speak(utterance);
                    log('info', `speechSynthesis.speak() è¿”å›: ${result}`);

                    if (result === false && speakAttempts < maxSpeakAttempts) {
                        log('warning', `è¿”å› falseï¼Œé‡è¯•ä¸­...`);
                        setTimeout(trySpeak, 200);
                    } else if (result === false) {
                        log('error', 'æ‰€æœ‰æ’­æ”¾å°è¯•éƒ½è¿”å› false');
                    } else {
                        log('success', 'è¯­éŸ³å·²æäº¤åˆ°é˜Ÿåˆ—');
                    }
                } catch (error) {
                    log('error', `æ’­æ”¾å¼‚å¸¸: ${error.message}`);
                    if (speakAttempts < maxSpeakAttempts) {
                        setTimeout(trySpeak, 200);
                    }
                }
            };

            // Start first attempt
            setTimeout(trySpeak, 100);
        }

        function stopSpeaking() {
            if (currentSpeaking !== null) {
                resetCard(currentSpeaking);
            }
            speechSynth.cancel();
            log('info', 'åœæ­¢æ‰€æœ‰æ’­æ”¾');
        }

        function resetCard(index) {
            const card = document.getElementById(`card-${index}`);
            const btn = document.getElementById(`play-${index}`);
            const statusBar = document.getElementById(`status-${index}`);
            const progressBar = document.getElementById(`progress-${index}`);

            card.classList.remove('speaking');
            btn.textContent = 'â–¶ï¸';
            btn.classList.remove('playing');
            statusBar.classList.remove('visible');
            progressBar.style.width = '0%';
            currentSpeaking = null;
        }

        function resetSpeechEngine() {
            log('info', 'å¼ºåˆ¶é‡ç½®è¯­éŸ³å¼•æ“...');

            // Cancel all speech
            speechSynth.cancel();
            log('info', 'å·²å–æ¶ˆæ‰€æœ‰è¯­éŸ³');

            // Reset audio unlock state
            isAudioUnlocked = false;

            // Reset button
            const btn = document.getElementById('unlockBtn');
            btn.disabled = false;
            btn.textContent = 'ğŸ”“ è§£é”éŸ³é¢‘';
            btn.classList.remove('unlocked');

            // Reset all cards
            for (let i = 0; i < testCharacters.length; i++) {
                resetCard(i);
            }

            log('success', 'è¯­éŸ³å¼•æ“å·²é‡ç½®ï¼Œè¯·é‡æ–°è§£é”');
        }

        function testSystemAudio() {
            log('info', 'æµ‹è¯•ç³»ç»ŸéŸ³é¢‘ (Web Audio API)...');

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioCtx = new AudioContext();

                // Create oscillator
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.2);

                log('success', 'âœ… ç³»ç»ŸéŸ³é¢‘æ’­æ”¾æˆåŠŸï¼å¦‚æœä½ å¬åˆ°äº† beep å£°ï¼Œè¯´æ˜ç³»ç»ŸéŸ³é¢‘æ­£å¸¸');
            } catch (error) {
                log('error', 'âŒ ç³»ç»ŸéŸ³é¢‘æµ‹è¯•å¤±è´¥: ' + error.message);
            }
        }

        function log(type, message) {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();

            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${time}]</span><span class="log-${type}">${message}</span>`;

            container.insertBefore(entry, container.firstChild);

            // Keep only last 50 logs
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }

            console.log(`[${type.toUpperCase()}] ${message}`);
        }
    </script>
</body>
</html>
